Section Overview:
  1) The best place to learn something is often the official documentation.
  2) How to architect and build the app.

Environment Setup For Mac:
  1) Yarn is simply another package manager.
    - Made by Facebook when NPM was having issues.
  2) NPM is perfectly stable now.
  3) You should not use both NPM and Yarn in the same folder.

NPM vs YARN:
  1) Install dependencies from package.json: 
    - npm install == yarn
  2) Install a package and add to package.json: 
    - npm install package --save == yarn add package
  3) Install a devDependency to package.json: 
    - npm install package --save-dev == yarn add package --dev
  4) Remove a dependency from package.json: 
    - npm uninstall package --save == yarn remove package
  5) Upgrade a package to its latest version: 
    - npm update --save == yarn upgrade
  6) Install a package globally: 
    - npm install package -g == yarn global add package

Create React App - NPX:
  1) NPX is a tool that gets included within NPM.
  2) NPM coordinate and leverage packages we download.
  3) NPX installs and executes immediately and gets deleted right after.

Create React App - React-Scripts 1:
  1) package.json writes what the dependencies of this app are.
  2) Entry point for every project is the index.js file.
  3) <App /> is the entire application.
  4) Everything lives inside what is being rendered.

Create React App - React-Scripts 2:
  1) When we deploy our code it needs to be optimized and to be efficiently small.
  2) npm build: 
    - React will generate an optimal build for us.
    - Different browsers consume the code slightly differently.
    - Main 2 packages: Babel and Webpack
      - Babel changes our code to older JS to make it easier for all browsers to understand.
      - Webpack: Modularizes our code. Optimize our code for better user experience.
  3) npm test: Ways for us to make sure the code does what we expect it to.
  4) npm eject:
    - Most of the time you don't need to use this.
  5) manifest.json file:
    - Used for progressive web app.
    - For people to download to access offline.
      - Use your application not through the browser.

Create React App - Everything Else:
  1) App.js represents our entire React application.
  2) React is using functions to return HTML.
  3) A component is a self-contained representations of HTML, CSS and JS.

Don't Eject:
  1) By usign create-react-app we automatically get the best system and project build out of the box therefore npm eject is very rarely needed and even used.

Monsters Rolodex - Class Components:
  1) A great React developer knows when React is rendering or re-rendering your website.
  2) Write things in either class or functional components with hooks.
  3) Functional components with hooks the more modern way.
  4) JSX: 
    - A syntax extension of JS.
    - Extended the functionality.
  5) Class component allows us to tell React what we expect it to render and how we expect it to render things.
  6) Class component allows us to tell explicitly what we want to render.

Monsters Rolodex - Component State:
  1) Local state is some information that only this component is aware of and can modify.
  2) The way to access the state is through constructors method.
  3) this.state is always a JSON object.
  4) Access a JS variables using {}.
  5) When variables change, React will re-render the information that represents the UI.

 Monsters Rolodex - setState:
  1) React allows to bind event handlers to any HTML tags.
  2) React determines when to re-render is when state is a completely different object in memory.
  3) Shallow merge: Shallow Merging means it only cares about the first level of the object and will replace anything deeper than the first level.
  4) setState updates the state to a different object.
    - React sees this as a different object in memory, the component is re-rendered.

Monsters Rolodex - States and Shallow Merge:
  1) Shallow merge only updates the keys for the values that are being passed to it.
  2) Shallow merge doesn't care the history or how it looked like.
  3) Make sure that when we update our state always use the same types of values.
  4) Set state should pass it a function is better. (Will be explained later)

Monsters Rolodex - setstate and Secondary Callback:
  1) setState is an asynchronous call.
    - setState has 2 arguments, first one is a function, second one is a callback function.
    - Callback functions will only run after the first function is completed.
  2) If we pass a function to setState,we get access to state and props.
  3) Props is something to do with components. (Will be explained later)
  4) Callback function is entirely optional.

Monsters Rolodex - Mapping Arrays to Elements:
  1) We can reuse the same HTML template using map.
  2) A good rule of thumb as to when to use the key attribute you saw in the previous video, is this: Anytime you use the map() function inside of render, or you have a list of the same jsx elements one after another, they need a key attribute.

Monsters Rolodex - Keys for Mapping:
  1) A key property is the element html that we're returning from our map.
  2) ID is the unique value most of the time.
  3) Why do we need the key value? Due to React and re-rendering.
    - Make it more optimized and efficient.
    - To differentiate between each item.
  4) React is the only thing that needs key values.

Monsters Rolodex - Single Page Applications (SPAs):
  1) With React, no need to go to server for the code when we navigate and change pages.
  2) Not entirely true when we do customized optimizations.

Monsters Rolodex - Lifecycle Method: componentDidMount:
  1) Where we're going to leverage the actual array once we get it inside our component.
  2) Application should not have to worry about what data looks like.
  3) We need to know what will be the empty (aka null) case.
  4) When do I get the list? How do I get the list? Where do I put the list?
  5) We want to get the API the moment it's rendered (aka mounted) by React.
  6) Mounting is the first time a component gets placed onto the DOM.
  7) What we fetch we want it in a JSON format.

Monsters Rolodex - Renders & Re-renders:
  1) Constructor runs before anything in any class.
  2) Render determines what to show.
  3) Once the render is mounted on the DOM, then the lifecycle method will be run.
  4) Key thing: understanding React class components when something re-renders.

Monsters Rolodex - Input Search Box Component:
  1) Always work on functionality of the application before working on CSS.
  2) For every html tag there is an equal React component.
  3) Note that some of it is named differently. (Example: class vs className)
  4) We shouldn't access anything starting with an underscore.
    - The main thing we want is 'target'.
  5) As a general practice you always want to use non modifying method.

Monsters Rolodex - Storing Original Data:
  1) We need to keep the original list for future reference.
  2) The best place to keep track of something is in the state.
  3) JS all variables are locally scoped.

Monsters Rolodex - Optimizations:
  1) Anonymous function: A function that is not stored anywhere in a variable.
  2) A function put inside a render is being run every single time.
    - A needless performance risk.
  3) Best to move it out.
  4) Use destructuring instead of using 'this' all the time.
    - More readable.

Monsters Rolodex - Understanding Components:
  1) React ties together the visual representation of UI and the functional representation of UI.
  2) Component aims to tie together reusable portions of the code into one segment.
  3) When you can create a component, you can genericize the functionality.
    - Becomes as reusable as possible.
  4) Ideally it has one single responsibility.

Monsters Rolodex - CardList Component:
  1) In component there can be only one parent level holder HTML tag.

Monsters Rolodex - Component Props:
  1) Props: Shorthand for properties.
  2) You can pass props from one component into another.

Monsters Rolodex - Rendering and Re-rendering part 2:
  1) Components will re-render when:
    - Props change.
    - setState gets called.
  2) This 2 is how React determines to re-render.
  3) React (Component tree) always renders from top-down.
    - Parent to child components. 